---
title: What's new in version 25.02?
description: Get to know the features, fixes, and functionality new in webforJ version 25.02.
slug: whats-new-v25.02
date: 2025-06-23
authors: webforJ
tags: [webforJ, v25.02, release]
image: "https://docs.webforj.com/release_blog/_images/25.02-social.png"
hide_table_of_contents: false
---

![cover image](../../static/release_blog/_images/25.02.png)

webforJ version `25.02` is here! This release introduces powerful integration capabilities with Spring Boot, enhanced data management with `Repository` improvements, better control over app lifecycle with listener support, and streamlined asynchronous UI updates with the new `runLater` API.

<!-- truncate -->

# 25.02

As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.02) for a more comprehensive list of changes. Highlighted below are some of the most exciting changes:

## New features and enhancements ðŸŽ‰

### Spring Boot integration

webforJ `25.02` introduces Spring Boot integration, bringing together webforJ's UI components and Spring's backend ecosystem. This integration allows users to leverage Spring's dependency injection, service layer, and data management while building modern web UIs with webforJ.

Many enterprise teams already have significant investments in Spring Boot infrastructure. This integration enables you to:
- Create new projects with Spring Boot functionality
- Use webforJ for the UI layer while maintaining existing Spring services
- Leverage Spring's dependency injection in webforJ components
- Connect directly to Spring Data repositories
- Benefit from Spring's extensive ecosystem and tooling

#### Key features

- **Dependency injection**: Autowire Spring beans directly into webforJ views and components
- **Spring Data integration**: Use `SpringDataRepository` to connect UI components to your data layer
- **Hot reload support**: Automatic browser refresh with Spring DevTools
- **Familiar development**: Keep using Spring annotations like `@Service`, `@Repository`, and `@Component`
- **Configuration flexibility**: Combine `application.properties` with `webforj.conf` for complete control

#### Getting started

Creating a new Spring Boot webforJ project is simple. You can either:

1. **Use startforJ**: Visit [start.webforj.com](https://start.webforj.com) and select Spring Boot as your framework
2. **Use Maven archetype**: Generate a project from the command line:
   ```bash
   mvn archetype:generate \
     -DarchetypeGroupId=com.webforj \
     -DarchetypeArtifactId=webforj-spring-boot-archetype \
     -DarchetypeVersion=LATEST
   ```

For existing projects, transform your webforJ app into a Spring Boot application with just a few changes:

```java
@SpringBootApplication
@Routify(packages = "com.example.views")
public class Application extends App {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    // Keep your existing run() method if you have one
    @Override
    public void run() {
        // Your existing initialization code
    }
}
```

#### Dependencies

Adding Spring Boot to your webforJ project requires just one starter dependency:

```xml
<dependency>
    <groupId>com.webforj</groupId>
    <artifactId>webforj-spring-boot-starter</artifactId>
    <version>${webforj.version}</version>
</dependency>
```

This starter automatically includes all necessary webforJ and Spring Boot dependencies, replacing the need for separate `webforj-foundation` and Spring dependencies. The starter handles the integration magic, ensuring both frameworks work together seamlessly.

#### Developer productivity with Spring DevTools

One of the immediate benefits of Spring Boot integration is enhanced developer productivity through Spring DevTools. When included in your project, DevTools provides:

- **Automatic restart**: Your application automatically restarts when you make code changes
- **LiveReload support**: Browser automatically refreshes when static resources change
- **Fast application restarts**: Only modified classes are reloaded, speeding up the development cycle
- **Development-time optimizations**: Caching is disabled and other settings are tuned for faster feedback

To enable DevTools, simply include it in your development dependencies for instant feedback on your changes.

:::tip
<!-- TODO -->
For more info on Spring data and JPA, see this article
:::

### Repository functionality overhaul

The `Repository` pattern in webforJ `25.02` has received an overhaul, introducing new features that improve data management and integration. The centerpiece of this update is the new `DelegatingRepository` class, alongside enhanced event handling and improved querying capabilities.

#### What's new?

**1. DelegatingRepository for custom data sources**

The new `DelegatingRepository` class dramatically simplifies integration with external data sources. Instead of implementing a full repository interface, you now need only three functions:

- **Find function**: Returns filtered, sorted, and paginated data
- **Count function**: Provides total count for pagination
- **Find by key function**: Retrieves single entities by ID

**2. Enhanced event system**

Repository events now provide granular control over data changes:
- React to single-entity or bulk updates
- Access detailed change information through commit events
- Build reactive UIs that automatically respond to data modifications

**3. Improved querying and filtering**

The repository query system has been refined for better flexibility:
- Set base filters that apply to all queries
- Combine multiple filter criteria seamlessly
- Integrate smoothly with UI components like tables and lists

#### Example: Creating a custom repository

```java
// Create a repository connected to a REST API
DelegatingRepository<Customer, CustomerFilter> repository = new DelegatingRepository<>(
    // Find function with full criteria support
    criteria -> {
        return apiClient.searchCustomers(
            criteria.getFilter(),
            criteria.getSort(),
            criteria.getPage()
        );
    },
    
    // Count function for pagination
    criteria -> apiClient.countCustomers(criteria.getFilter()),
    
    // Find by key for single-entity retrieval
    customerId -> apiClient.getCustomer(customerId)
);

// Set a base filter for all queries
CustomerFilter baseFilter = new CustomerFilter();
baseFilter.setStatus("ACTIVE");
repository.setBaseFilter(baseFilter);

// React to data changes
repository.onCommit(event -> {
    if (event.isSingleCommit()) {
        Customer updated = event.getFirstCommit();
        showToast("Customer " + updated.getName() + " updated!");
    }
});

// Use with UI components
Table<Customer> customerTable = new Table<>();
customerTable.setRepository(repository);
```

These enhancements make the Repository pattern more powerful and flexible than ever, enabling seamless integration with any data source while maintaining a consistent, reactive programming model throughout your webforJ applications.

### App lifecycle listeners

webforJ `25.02` introduces the `AppLifecycleListener` interface, providing a way to observe and respond to app lifecycle events. This feature lets developers hook into critical app phases, where it can be used for initialization tasks, resource cleanup, and building plugin architectures.

#### How it works

The `AppLifecycleListener` interface provides four key methods that are called at different stages of the app lifecycle:

- **`onWillRun(App app)`**: Called just before the app starts running
- **`onDidRun(App app)`**: Called after the app has successfully started
- **`onWillTerminate(App app)`**: Called before the app begins termination
- **`onDidTerminate(App app)`**: Called after the app has terminated

#### Key features

- **Automatic discovery**: Listeners are automatically discovered at runtime through service provider configuration
- **Isolated execution**: Each app instance gets its own set of listeners, ensuring proper isolation
- **Exception resilience**: Exceptions in listeners are logged but don't prevent app execution
- **Priority control**: Use `@AppListenerPriority` to control execution order when multiple listeners are present

#### Example usage

```java
public class DatabaseInitListener implements AppLifecycleListener {
    @Override
    public void onWillRun(App app) {
        // Initialize database connection pool
        DatabasePool.initialize();
        System.out.println("Database initialized for app: " + app.getId());
    }
    
    @Override
    public void onWillTerminate(App app) {
        // Clean up resources
        DatabasePool.shutdown();
        System.out.println("Database connections closed");
    }
}
```

To register your listener, create a service provider configuration file at `META-INF/services/com.webforj.AppLifecycleListener` or use the `@AutoService` annotation:

```java
@AutoService(AppLifecycleListener.class)
@AppListenerPriority(100) // Higher priority executes first
public class CriticalStartupListener implements AppLifecycleListener {
    // Implementation
}
```

This feature opens up possibilities for cross-cutting concerns, from logging and monitoring to dependency injection and plugin systems.

### Asynchronous UI updates with `runLater`

webforJ `25.02` introduces the experimental `Environment.runLater()` API, providing a way to update the UI from background threads. This feature enables integration of long-running operations while maintaining UI responsiveness.

#### Why `runLater`

webforJ enforces a single-threaded UI model where all component updates must occur on the `Environment` thread. This prevents race conditions but creates challenges when integrating asynchronous operations. The `runLater` API bridges this gap by allowing background threads to safely queue UI updates.

#### Key features

- **Thread-safe UI updates**: Queue UI modifications from any background thread with automatic context inheritance
- **Synchronous execution from UI thread**: When called from the UI thread, tasks execute immediately without queuing overhead
- **Task cancellation**: Cancel pending updates to prevent memory leaks and outdated UI changes
- **FIFO ordering**: All queued tasks execute in strict order

#### Example usage

```java
@Route
public class DataView extends Composite<Div> {
    private Button loadButton = new Button("Load Data");
    private Paragraph statusText = new Paragraph("Ready");
    
    public DataView() {
        loadButton.onClick(e -> {
            statusText.setText("Loading...");
            
            CompletableFuture.runAsync(() -> {
                // Simulate data fetching
                String data = fetchDataFromAPI();
                
                // Update UI from background thread
                Environment.runLater(() -> {
                    statusText.setText("Data loaded: " + data);
                    loadButton.setEnabled(true);
                });
            });
        });
    }
}
```

The API automatically handles context inheritance, so child threads created within the `Environment` can use `runLater` without additional configuration. For production use, always track `PendingResult` objects and cancel them in component lifecycle methods to prevent memory leaks.

:::warning Experimental API
The `runLater` API is marked as experimental and may change in future releases. The API signature, behavior, and performance characteristics are subject to modification.
:::

For a complete implementation example and best practices, see the [asynchronous updates documentation](../../docs/advanced/asynchronous-updates).

As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.02) for a more comprehensive list of changes.