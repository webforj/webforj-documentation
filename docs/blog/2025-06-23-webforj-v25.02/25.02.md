---
title: What's new in version 25.02?
description: Get to know the features, fixes, and functionality new in webforJ version 25.02.
slug: whats-new-v25.02
date: 2025-06-23
authors: webforJ
tags: [webforJ, v25.02, release]
image: "https://docs.webforj.com/release_blog/_images/25.02-social.png"
hide_table_of_contents: false
---

![cover image](../../static/release_blog/_images/25.02.png)

webforJ version `25.02` is here! This release introduces powerful integration capabilities with Spring Boot, enhanced data management with `Repository` improvements, better control over app lifecycle with listener support, and streamlined asynchronous UI updates with the new `runLater` API.

<!-- truncate -->

# 25.02

As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.02) for a more comprehensive list of changes. Highlighted below are some of the most exciting changes:

## New features and enhancements ðŸŽ‰

### Spring Boot integration

<!-- TODO -->

### Repository functionality overhaul

The `Repository` pattern in webforJ `25.02` has received an overhaul, introducing new features that improve data management and integration. The centerpiece of this update is the new `DelegatingRepository` class, alongside enhanced event handling and improved querying capabilities.

#### What's new?

**1. DelegatingRepository for custom data sources**

The new `DelegatingRepository` class dramatically simplifies integration with external data sources. Instead of implementing a full repository interface, you now need only three functions:

- **Find function**: Returns filtered, sorted, and paginated data
- **Count function**: Provides total count for pagination
- **Find by key function**: Retrieves single entities by ID

**2. Enhanced event system**

Repository events now provide granular control over data changes:
- React to single-entity or bulk updates
- Access detailed change information through commit events
- Build reactive UIs that automatically respond to data modifications

**3. Improved querying and filtering**

The repository query system has been refined for better flexibility:
- Set base filters that apply to all queries
- Combine multiple filter criteria seamlessly
- Integrate smoothly with UI components like tables and lists

#### Example: Creating a custom repository

```java
// Create a repository connected to a REST API
DelegatingRepository<Customer, CustomerFilter> repository = new DelegatingRepository<>(
    // Find function with full criteria support
    criteria -> {
        return apiClient.searchCustomers(
            criteria.getFilter(),
            criteria.getSort(),
            criteria.getPage()
        );
    },
    
    // Count function for pagination
    criteria -> apiClient.countCustomers(criteria.getFilter()),
    
    // Find by key for single-entity retrieval
    customerId -> apiClient.getCustomer(customerId)
);

// Set a base filter for all queries
CustomerFilter baseFilter = new CustomerFilter();
baseFilter.setStatus("ACTIVE");
repository.setBaseFilter(baseFilter);

// React to data changes
repository.onCommit(event -> {
    if (event.isSingleCommit()) {
        Customer updated = event.getFirstCommit();
        showToast("Customer " + updated.getName() + " updated!");
    }
});

// Use with UI components
Table<Customer> customerTable = new Table<>();
customerTable.setRepository(repository);
```

These enhancements make the Repository pattern more powerful and flexible than ever, enabling seamless integration with any data source while maintaining a consistent, reactive programming model throughout your webforJ applications.

### App lifecycle listeners

webforJ `25.02` introduces the `AppLifecycleListener` interface, providing a way to observe and respond to app lifecycle events. This feature lets developers hook into critical app phases, where it can be used for initialization tasks, resource cleanup, and building plugin architectures.

#### How it works

The `AppLifecycleListener` interface provides four key methods that are called at different stages of the app lifecycle:

- **`onWillRun(App app)`**: Called just before the app starts running
- **`onDidRun(App app)`**: Called after the app has successfully started
- **`onWillTerminate(App app)`**: Called before the app begins termination
- **`onDidTerminate(App app)`**: Called after the app has terminated

#### Key features

- **Automatic discovery**: Listeners are automatically discovered at runtime through service provider configuration
- **Isolated execution**: Each app instance gets its own set of listeners, ensuring proper isolation
- **Exception resilience**: Exceptions in listeners are logged but don't prevent app execution
- **Priority control**: Use `@AppListenerPriority` to control execution order when multiple listeners are present

#### Example usage

```java
public class DatabaseInitListener implements AppLifecycleListener {
    @Override
    public void onWillRun(App app) {
        // Initialize database connection pool
        DatabasePool.initialize();
        System.out.println("Database initialized for app: " + app.getId());
    }
    
    @Override
    public void onWillTerminate(App app) {
        // Clean up resources
        DatabasePool.shutdown();
        System.out.println("Database connections closed");
    }
}
```

To register your listener, create a service provider configuration file at `META-INF/services/com.webforj.AppLifecycleListener` or use the `@AutoService` annotation:

```java
@AutoService(AppLifecycleListener.class)
@AppListenerPriority(100) // Higher priority executes first
public class CriticalStartupListener implements AppLifecycleListener {
    // Implementation
}
```

This feature opens up possibilities for cross-cutting concerns, from logging and monitoring to dependency injection and plugin systems.

### Asynchronous UI updates with `runLater`

webforJ `25.02` introduces the experimental `Environment.runLater()` API, providing a way to update the UI from background threads. This feature enables integration of long-running operations while maintaining UI responsiveness.

#### Why `runLater`

webforJ enforces a single-threaded UI model where all component updates must occur on the `Environment` thread. This prevents race conditions but creates challenges when integrating asynchronous operations. The `runLater` API bridges this gap by allowing background threads to safely queue UI updates.

#### Key features

- **Thread-safe UI updates**: Queue UI modifications from any background thread with automatic context inheritance
- **Synchronous execution from UI thread**: When called from the UI thread, tasks execute immediately without queuing overhead
- **Task cancellation**: Cancel pending updates to prevent memory leaks and outdated UI changes
- **FIFO ordering**: All queued tasks execute in strict order

#### Example usage

```java
@Route
public class DataView extends Composite<Div> {
    private Button loadButton = new Button("Load Data");
    private Paragraph statusText = new Paragraph("Ready");
    
    public DataView() {
        loadButton.onClick(e -> {
            statusText.setText("Loading...");
            
            CompletableFuture.runAsync(() -> {
                // Simulate data fetching
                String data = fetchDataFromAPI();
                
                // Update UI from background thread
                Environment.runLater(() -> {
                    statusText.setText("Data loaded: " + data);
                    loadButton.setEnabled(true);
                });
            });
        });
    }
}
```

The API automatically handles context inheritance, so child threads created within the `Environment` can use `runLater` without additional configuration. For production use, always track `PendingResult` objects and cancel them in component lifecycle methods to prevent memory leaks.

:::warning Experimental API
The `runLater` API is marked as experimental and may change in future releases. The API signature, behavior, and performance characteristics are subject to modification.
:::

For a complete implementation example and best practices, see the [asynchronous updates documentation](../../docs/advanced/asynchronous-updates).

As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.02) for a more comprehensive list of changes.