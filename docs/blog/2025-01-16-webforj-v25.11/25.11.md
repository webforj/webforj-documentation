---
title: What's new in version 25.11?
description: Get to know the features, fixes, and functionality new in webforJ version 25.11.
slug: whats-new-v25.11
date: 2025-01-16
authors: webforJ
tags: [webforJ, v25.11, release]
image: "https://cdn.webforj.com/webforj-documentation/blogs/webforj-v25.11/cover.png"
hide_table_of_contents: false
---

![cover image](https://cdn.webforj.com/webforj-documentation/blogs/webforj-v25.11/cover.png)

<!-- TODO: Write intro paragraph summarizing the release highlights -->

<!-- truncate -->

As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.11) for a more comprehensive list of changes. Highlighted below are some of the most exciting changes:

## View Transitions API for animated route navigation

Route changes no longer have to be jarring. This release introduces experimental support for the browser's native [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API), bringing smooth animations to navigation with minimal effort.

<!-- <video src={require('./transitions.mp4').default} autoPlay muted loop playsInline style={{width: '100%', borderRadius: '8px', marginBottom: '1rem'}}></video> -->

The simplest approach, and the one used in the above video is the `@RouteTransition` annotation:

```java
@Route
@RouteTransition(enter = ViewTransition.SLIDE_LEFT, exit = ViewTransition.SLIDE_RIGHT)
public class DetailView extends Composite<Div> {
    // ...
}
```

That's it - the router handles the animation automatically when navigating to or from this view. Built-in transitions include `FADE`, `SLIDE_LEFT`, `SLIDE_RIGHT`, `SLIDE_UP`, `SLIDE_DOWN`, `ZOOM`, and `ZOOM_OUT`.

For more control, the programmatic API lets you orchestrate transitions manually:

```java
Page.getCurrent().startViewTransition()
    .exit(oldView, ViewTransition.FADE)
    .enter(newView, ViewTransition.SLIDE_LEFT)
    .onUpdate(done -> {
        container.remove(oldView);
        container.add(newView);
        done.run();
    })
    .start();
```

The API also supports shared element transitions - mark elements with matching transition names using `setViewTransitionName()`, and the browser morphs them automatically between views. Think: a thumbnail in a list smoothly expanding into a hero image on a detail page.

## JBang integration for instant prototyping

Want to try a webforJ idea without worrying about scaffolding a whole new Java project? Now you can. The new **JBang integration** lets you write and run small webforJ apps in just a single file, without config files and lots of installations - no `pom.xml`, no project structure, no build configuration. Just install Jbang, add the dependency directive and run.

<!-- <video src={require('./jbang.mp4').default} autoPlay muted loop playsInline style={{width: '100%', borderRadius: '8px', marginBottom: '1rem'}}></video> -->

```java
///usr/bin/env jbang "$0" "$@" ; exit $?
//DEPS com.webforj:webforj-jbang-starter:25.11
//JAVA 21

@SpringBootApplication
public class Counter extends App {
  private int count = 0;

  @Override
  public void run() throws WebforjException {
    Frame frame = new Frame();
    H1 counter = new H1("0");
    Button btn = new Button("Click me", e -> counter.setText(String.valueOf(++count)));
    frame.add(FlexLayout.create(counter, btn).vertical().build());
  }
}
```

Run the above snippet with `jbang Counter.java` and your browser opens automatically. It's perfect for rapid prototyping, demos, and learning webforJ without the ceremony that comes along with traditional Java projects.

:::info Learn More
See the [JBang integration docs](/docs/integrations/jbang) for installation, configuration options, and tips for transitioning prototypes to full projects.
:::

## Avatar component

Profiles, comments, team lists, activity feeds - user avatars show up everywhere. The new **Avatar** component makes them trivial to implement:

```java
// Auto-generated initials from name
Avatar avatar = new Avatar("John Doe"); // Shows "JD"

// With a profile image
Avatar avatar = new Avatar("Jane Smith");
avatar.add(new Img("https://example.com/profile.jpg"));
```

Pass a name and Avatar automatically generates initials. Need an image instead? Add it as a child. Seven themes (primary, success, danger, etc.), two shapes (circle or square), and sizes from tiny to extra-large cover the common cases. Avatars are clickable too, so wiring up profile menus takes just a click handler.

:::info Learn More
See the [Avatar component docs](/docs/components/avatar) for themes, shapes, and customization options.
:::

## Markdown Viewer component

AI interfaces have raised the bar for how users expect to see streamed content - text should appear progressively, not dump all at once. The new **MarkdownViewer** component brings that experience to webforJ with built-in progressive rendering support.

<!-- <video src={require('./ghost-ai.mp4').default} autoPlay muted loop playsInline style={{width: '100%', borderRadius: '8px', marginBottom: '1rem'}}></video> -->

*The video above showcases the MarkdownViewer rendering streamed output from an AI chatbot in real time.*

:::tip AI Autocompletion
Notice the text area in the demo? It features AI-powered autocompletion that suggests text as you type. This ghost text functionality is also available in the TextField and TextArea components - see [TextField documentation](/docs/components/fields/text-field) for details on enabling suggestions in your own apps.
:::

```java
MarkdownViewer viewer = new MarkdownViewer();
viewer.setProgressiveRender(true);
viewer.setAutoScroll(true);

// As chunks arrive from your AI service...
aiService.stream(prompt).subscribe(chunk -> {
    viewer.append(chunk);
});
```

Each call to `append()` adds content to the stream. Auto-scroll keeps the latest content visible - and it's smart enough to pause when users scroll up to read, resuming when they return to the bottom. Code blocks get syntax highlighting via Prism.js automatically.

The API gives you full control: `setRenderSpeed()` adjusts how fast characters appear, `stop()` cancels mid-stream, `flush()` displays all remaining content immediately, and `whenRenderComplete()` lets you know when rendering finishes - useful for enabling a "copy" button or similar UI.

## Debouncer utility

Ever notice how search-as-you-type can hammer your server with requests on every keystroke? The new **Debouncer** utility solves this and other similar issues - it waits until the user pauses before executing, so you only process what matters.

```java
Debouncer debounce = new Debouncer(0.3f);

textField.onModify(e -> {
    debounce.run(() -> search(textField.getText()));
});
```

Type as fast as you want - the search only fires after 300ms of inactivity. Need to force immediate execution? Call `flush()`. Changed your mind? Call `cancel()`. The API is minimal but covers real-world needs like showing loading states with `isPending()`. 

Built on webforJ's `Interval` class, it runs on the UI thread without synchronization headaches - just clean, predictable debouncing.

:::info Learn More
See the [Debouncer docs](/docs/advanced/debouncing) for control methods and cleanup patterns.
:::

## Minify plugin for build-time asset optimization

Add a plugin to your build, ship smaller bundles. The new **webforJ minify plugin** compresses CSS and JavaScript files automatically during compilation.

There's nothing new to configure - the plugin discovers assets through your existing `@StyleSheet` and `@JavaScript` annotations. It skips files that are already minified and processes larger projects in parallel. Maven and Gradle are both supported.

:::info Learn More
See the [Minify plugin docs](/docs/configuration/minifier-plugin) for setup instructions and configuration options.
:::

## Route Registry Provider SPI

By default, webforJ discovers routes by scanning the classpath for `@Route` annotations. That works great for standalone apps, but integration frameworks like Spring have their own way of managing components - they want routes to participate in dependency injection, lifecycle callbacks, and scoped beans.

The new **RouteRegistryProvider SPI** opens the door. It's a "Service Provider Interface" that lets frameworks plug in their own route discovery logic. When you call `RouteRegistry.ofPackage()`, webforJ now checks for registered providers first. If one exists (like Spring's implementation), it delegates discovery to that provider. Otherwise, it falls back to standard classpath scanning.

For most developers, this is invisible - routes just work. But if you're building framework integrations or need custom route registration logic, you now have a clean extension point.

## Spring Boot starter simplification

A small but welcome change: the `webforj-spring-boot-starter` now includes webforJ as a transitive dependency. Previously you needed to declare both the starter and the core library separately. Now just add the starter and you're done - one dependency instead of two.


## Built with webforJ: Demo applications

We're continuing to add to our collection of demo applications that showcase what's possible with webforJ. Each project is open source and demonstrates real-world patterns you can learn from and adapt. Those interested in learning more are encouraged to clone and run the projects, explore the source code, and implement patterns from these apps in their projects. 

This release, we've added the following projects:

### ghost:ai

<!-- <video src={require('./ghostai-demo.mp4').default} autoPlay muted loop playsInline style={{width: '100%', borderRadius: '8px', marginBottom: '1rem'}}></video> -->

Mentioned at the beginning of our article, GhostAI is a full-featured AI chat application built with Spring AI and Google Gemini. The interface mirrors the ChatGPT experience: streaming responses render progressively in the `MarkdownViewer` with syntax-highlighted code blocks, while the input field offers predictive ghost text suggestions that you can accept with Tab. Conversation history persists across messages, and MCP server integration enables real-time documentation queries.

This demo pulls together many of the new 25.11 features - MarkdownViewer's progressive rendering, TextField's ghost text API, and the `Debouncer` utility - into a cohesive application.

[View source on GitHub](https://github.com/webforj/built-with-webforj/tree/main/webforj-ghostai)

### Focus Tracker

<!-- <video src={require('./focustracker-demo.mp4').default} autoPlay muted loop playsInline style={{width: '100%', borderRadius: '8px', marginBottom: '1rem'}}></video> -->

A Pomodoro-style timer that demonstrates Progressive Web App capabilities in webforJ. Install it to your desktop or mobile device using the `@AppProfile` annotation, receive native notifications when your focus session ends, and watch the app badge update in real-time to show remaining minutes.

For Java developers accustomed to server-side rendering, this demo shows how webforJ bridges the gap to modern web platform features - installable apps, push notifications, and badge APIs - without writing JavaScript.

[View source on GitHub](https://github.com/webforj/built-with-webforj/tree/main/webforj-focustracker)

### REST Pagination

A practical comparison of two pagination strategies for REST API data. The first tab uses `CollectionRepository` to fetch all 100 customers upfront and paginate client-side - simple and fast for small datasets. The second tab uses `DelegatingRepository` to lazy-load 15 records at a time as you navigate - essential for large datasets where loading everything would be impractical.

Both approaches use the same Table component and Navigator, making it easy to compare the trade-offs between memory usage, network requests, and implementation complexity.

[View source on GitHub](https://github.com/webforj/built-with-webforj/tree/main/webforj-rest)

## Documentation enhancements

The docs received some attention this release too:

- **Revamped component articles** - The [Component Fundamentals](/docs/building-ui/component-fundamentals) article has been revamped to give a more thorough and comprehensive overview of the nuts and bolts of the component model, lifecycle, and best practices for building UIs with webforJ, providing new and experienced webforJ developers with a solid foundation for building UIs.

- **AI-powered search** - The documentation site now features AI search. Ask natural language questions about webforJ and get relevant answers drawn from across the documentation, complete with links to the source material.

---

That wraps up the major features introduced in webforJ `25.11`. As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.11) for a more comprehensive list of changes.