---
title: What's new in version 25.11?
description: Get to know the features, fixes, and functionality new in webforJ version 25.11.
slug: whats-new-v25.11
date: 2025-01-16
authors: webforJ
tags: [webforJ, v25.11, release]
image: "https://cdn.webforj.com/webforj-documentation/blogs/webforj-v25.11/cover.png"
hide_table_of_contents: false
---

![cover image](https://cdn.webforj.com/webforj-documentation/blogs/webforj-v25.11/cover.png)

<!-- TODO: Write intro paragraph summarizing the release highlights -->

<!-- truncate -->

As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.11) for a more comprehensive list of changes. Highlighted below are some of the most exciting changes:

## View Transitions API for animated route navigation

<!-- TODO: PR #1178 - feat: add View Transitions API support for animated route navigation -->

## JBang integration for instant prototyping

Want to try a webforJ idea without worrying about scaffolding a whole new Java project? Now you can. The new **JBang integration** lets you write and run small webforJ apps in just a single file, without config files and lots of installations - no `pom.xml`, no project structure, no build configuration. Just install Jbang, add the dependency directive and run.

```java
///usr/bin/env jbang "$0" "$@" ; exit $?
//DEPS com.webforj:webforj-jbang-starter:25.11
//JAVA 21

@SpringBootApplication
public class Counter extends App {
  private int count = 0;

  @Override
  public void run() throws WebforjException {
    Frame frame = new Frame();
    H1 counter = new H1("0");
    Button btn = new Button("Click me", e -> counter.setText(String.valueOf(++count)));
    frame.add(FlexLayout.create(counter, btn).vertical().build());
  }
}
```

Run the above snippet with `jbang Counter.java` and your browser opens automatically. When you close the tab, the server shuts down - no orphaned processes cluttering your machine. It's perfect for rapid prototyping, demos, and learning webforJ without the ceremony.

:::info Learn More
See the [JBang integration docs](/docs/integrations/jbang) for installation, configuration options, and tips for transitioning prototypes to full projects.
:::

## Avatar component

Nearly every app needs user avatars - for profiles, comments, team lists, activity feeds. The new **Avatar** component handles it all with minimal code. Pass a name and it automatically generates initials, or add an image or icon as a child component.

```java
// Auto-generated initials from name
Avatar avatar = new Avatar("John Doe"); // Shows "JD"

// With a profile image
Avatar avatar = new Avatar("Jane Smith");
avatar.add(new Img("https://example.com/profile.jpg"));
```

Avatars come with seven themes (primary, success, danger, and more), two shapes (circle for people, square for teams or apps), and sizes ranging from tiny to extra-large. They're clickable too - wire up profile menus or detail views with a simple click handler.

:::info Learn More
See the [Avatar component docs](/docs/components/avatar) for themes, shapes, and customization options.
:::

## Markdown Viewer component

<!-- TODO Add clip or demo from the ghostAI demo -->

Hopping on the bandwagon and building an AI chat interface? The new **MarkdownViewer** component renders Markdown with progressive streaming support - content displays live as it arrives, just like you'd expect from a modern chat experience.

Call `append()` to push new content as it streams in, and the viewer renders it incrementally. Enable auto-scroll and the view follows along automatically. When you need to know rendering is complete (maybe to enable a "copy" button), `whenRenderComplete()` has you covered. Code blocks get automatic syntax highlighting via Prism.js.

Control the experience with `setProgressiveRender()` and `setRenderSpeed()`, or use `stop()`, `flush()`, and `clear()` to manage the streaming lifecycle.

## Debouncer utility

Ever notice how search-as-you-type can hammer your server with requests on every keystroke? The new **Debouncer** utility solves this and other similar issues - it waits until the user pauses before executing, so you only process what matters.

```java
Debouncer debounce = new Debouncer(0.3f);

textField.onModify(e -> {
    debounce.run(() -> search(textField.getText()));
});
```

Type as fast as you want - the search only fires after 300ms of inactivity. Need to force immediate execution? Call `flush()`. Changed your mind? Call `cancel()`. The API is minimal but covers real-world needs like showing loading states with `isPending()`. 

Built on webforJ's `Interval` class, it runs on the UI thread without synchronization headaches - just clean, predictable debouncing.

:::info Learn More
See the [Debouncer docs](/docs/advanced/debouncing) for control methods and cleanup patterns.
:::

## Minify plugin for build-time asset optimization

Smaller assets mean faster load times. The new **webforJ minify plugin** automatically compresses your CSS and JavaScript files during the build.

The plugin discovers assets through your existing `@StyleSheet` and `@JavaScript` annotations, so there's nothing new to learn. Just add the plugin to your Maven or Gradle build and your production bundles shrink automatically. It's smart enough to skip files that are already minified, and for larger projects with 10+ assets, it processes files in parallel.

Works with both Maven and Gradle, integrating cleanly into your existing build lifecycle.

:::info Learn More
See the [Minify plugin docs](/docs/configuration/minifier-plugin) for setup instructions and configuration options.
:::

## Route Registry Provider SPI

By default, webforJ discovers routes by scanning the classpath for `@Route` annotations. That works great for standalone apps, but integration frameworks like Spring have their own way of managing components - they want routes to participate in dependency injection, lifecycle callbacks, and scoped beans.

The new **RouteRegistryProvider SPI** opens the door. It's a "Service Provider Interface" that lets frameworks plug in their own route discovery logic. When you call `RouteRegistry.ofPackage()`, webforJ now checks for registered providers first. If one exists (like Spring's implementation), it delegates discovery to that provider. Otherwise, it falls back to standard classpath scanning.

For most developers, this is invisible - routes just work. But if you're building framework integrations or need custom route registration logic, you now have a clean extension point.

## Spring Boot starter simplification

A small but welcome change: the `webforj-spring-boot-starter` now includes webforJ as a transitive dependency. Previously you needed to declare both the starter and the core library separately. Now just add the starter and you're done - one dependency instead of two.

---

That wraps up the major features introduced in webforJ `25.11`. As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.11) for a more comprehensive list of changes.