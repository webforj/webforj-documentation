---
title: What's new in version 25.03?
description: Get to know the features, fixes, and functionality new in webforJ version 25.03.
slug: whats-new-v25.03
date: 2025-09-04
authors: webforJ
tags: [webforJ, v25.03, release]
# image: "https://docs.webforj.com/release_blog/_images/25.03-social.png"
hide_table_of_contents: false
---

<!-- TODO: Replace with actual 25.03 images -->
![cover image](/release_blog/_images/25.02.png)

webforJ version `25.03` introduces new capabilities for configuration management, Spring integration options, routing improvements, and `Table` component updates.

<!-- truncate -->

As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.03) for a more comprehensive list of changes. Highlighted below are some of the most exciting changes:

## New features and enhancements ðŸŽ‰

### Early lifecycle hooks for configuration management

Apps often need to perform operations such as validating environment variables, configuring logging systems, or establishing database connections before the main app logic begins. The new `onWillCreate` and `onDidCreate` lifecycle hooks in webforJ `25.03` solve this by providing precise intervention points during app startup, giving you control over configuration and setup tasks at exactly the right moment.

These hooks integrate into the bootstrap process. The `onWillCreate` hook fires just before your app instance is created, perfect for modifying configuration or validating prerequisites. The `onDidCreate` hook executes immediately after creation but before the app starts serving requests, ideal for post-initialization setup that depends on a fully configured app context.

#### Practical implementation

Consider a scenario where you need to configure different database connections based on the deployment environment and set up application monitoring:

<!-- Need to come up with better code snippets -->

```java
@AppLifecycleListener
public class AppConfigurationManager {
    
    @Override
    public void onWillCreate() {
        // Validate required environment variables
        validateEnvironment();
        
        // Dynamically configure based on deployment context
        String env = System.getenv("DEPLOYMENT_ENV");
        if ("production".equals(env)) {
            config.set("database.pool.size", "50");
            config.set("cache.enabled", "true");
        } else {
            config.set("database.pool.size", "5");
            config.set("debug.mode", "true");
        }
    }
    
    @Override
    public void onDidCreate() {
        Logger.info("Application initialized with config: " + app.getConfig());
    }
}
```

Use `onWillCreate` when you need to:
- Modify configuration before it's locked
- Validate environment requirements
- Set up resources that the app depends on

Use `onDidCreate` when you need to:
- Initialize monitoring or logging systems
- Register custom handlers or services
- Perform setup that requires app context


:::info
For more information on lifecycle hooks and configuration management, see the [Lifecycle Listeners](/docs/advanced/lifecycle-listeners) docs.
:::

### Spring properties file configuration support

Managing configuration across different environments just got easier. webforJ `25.03` brings integration with Spring Boot's configuration system, allowing you to configure everything from servlet mappings to debug settings directly in your familiar `application.properties` or `application.yml` files. Now, your webforJ settings now live alongside your Spring configuration under the `webforj.*` prefix.

This integration goes beyond simple property mapping. Spring's powerful profile system means you can maintain separate configurations for development, staging, and production environments, all managed through standard Spring mechanisms. Switch between profiles with a single command-line argument or environment variable, and your webforJ app automatically picks up the right configuration.

#### Configuration in action

Here's how you might configure a webforJ app using Spring properties:

```yaml
# application.yml
webforj:
  entry: com.mycompany.app.MyApplication
  debug: false
  servlet-mapping: /app/*
  session-timeout: 3600
  
  # File upload configuration
  upload:
    max-file-size: 10MB
    allowed-extensions: pdf,docx,xlsx
  
  # Additional servlets
  servlets:
    api:
      class: com.mycompany.api.RestServlet
      mapping: /api/*
      init-params:
        cors-enabled: true
        rate-limit: 1000

# Environment-specific overrides in application-dev.yml
spring:
  profiles: dev
  
webforj:
  debug: true
  session-timeout: 7200
  heartbeat-interval: 30
```

For traditional properties file users, the same configuration works equally well:

```properties
# application.properties
webforj.entry=com.mycompany.app.MyApplication
webforj.debug=false
webforj.servletMapping=/app/*
webforj.sessionTimeout=3600

# Spring profile activation
spring.profiles.active=production
```

The beauty of this integration is that it respects Spring Boot's configuration hierarchy. Properties from environment variables, command-line arguments, and external configuration sources all work as expected, providing flexibility in how you deploy and configure your applications.

:::tip Configuration migration
Moving from `webforj.conf` to Spring properties? Both approaches work side-by-side during migration. Spring properties take precedence when both are present, allowing for piecewise transition.
:::

:::info
Learn more about Spring Boot configuration in the [Spring Integration](/docs/integrations/spring/setup) documentation.
:::

### Router Activate lifecycle event for cached components

The new `ActivateEvent` in webforJ `25.03` enables components to intelligently handle reactivation when users navigate back to them. When navigating back to a cached component instead of creating a new one, the `onActivate` method fires, providing a hook for refreshing data while preserving component state. 

For example, if you have a complex form where users configure product options, they can navigate away to check shipping details and return to find their configuration intact, while the component refreshes any price or availability data that might have changed.

This is particularly powerful for parameter-driven routes. Say you have a customer detail view at `/customer/:id`. Previously, navigating from customer 123 to customer 456 meant either recreating the entire component (losing any unsaved work) or manually checking for parameter changes. Now, the router handles this elegantly â€“ the component stays cached, and `onActivate` gives you the perfect moment to load new customer data while keeping the UI state intact.

#### Smart component reactivation

Here's how you might implement a product catalog that efficiently handles navigation between products:

```java
@Route(value = "/product/:productId", outlet = MainLayout.class)
public class ProductDetailView extends Composite<Div> implements ActivateObserver {
    
    private final ProductService productService;
    private TextField quantityField;
    private ChoiceBox colorSelector;
    
    @Override
    public void onActivate(ActivateEvent event, ParametersBag params) {
        // Component is being reused with new parameters
        String productId = params.get("productId").orElse("");
        
        // Load new product data without recreating the entire view
        productService.loadProduct(productId).thenAccept(product -> {
            updateProductDisplay(product);
            // User's quantity selection and other inputs remain intact
            console().log("Loaded product: " + product.getName());
        });
    }
    
    private void updateProductDisplay(Product product) {
        // Update only the product-specific content
        // Form inputs and user selections are preserved
    }
}
```

The `ActivateObserver` interface provides a separation between initial component creation (handled by existing lifecycle methods) and reactivation scenarios. This means better performance through component reuse and preserved state, and cleaner code that clearly expresses intent.

Some good scenarios for implementing the `ActivateObserver` include when your route component:
- Displays data based on route parameters
- Contains user input that should persist during navigation
- Performs expensive initialization you want to avoid repeating
- Needs to refresh specific data without full reconstruction

### Spring custom scopes for webforJ environments and routes

Standard Spring scopes like `@RequestScoped` and `@SessionScoped` work well for traditional web applications, but webforJ's component-based architecture demands more nuanced lifecycle management. The new `@EnvironmentScope` and `@RouteScope` annotations in `25.03` align bean lifecycles with webforJ's runtime model, making sure beans exist exactly as long as they're needed â€“ no longer, no shorter.

`@EnvironmentScope` ties beans to browser windows or tabs. Each tab gets its own isolated instance, perfect for user session data, authentication state, or tab-specific preferences. When a user opens your app in multiple tabs, each tab maintains its own state without interference. 

Meanwhile, `@RouteScope` binds beans to route hierarchies â€“ parent and child routes share the same bean instances, but navigating to a different route tree creates fresh instances. This is ideal for managing form data across multi-step workflows or maintaining navigation state within a feature area.

#### Scopes in practice

Consider a multi-step order workflow where state needs to persist across route navigation:

```java
@Service
@RouteScope
public class OrderWorkflowService {
    private OrderData currentOrder = new OrderData();
    private ValidationResults validationState;
    
    public void updateOrderStep(StepData data) {
        // State persists across child routes in the order flow
        currentOrder.mergeStep(data);
    }
    
    // Bean is automatically cleaned up when user leaves the order workflow
}

@Route("/order/shipping")
public class ShippingView extends Composite<Div> {
    
    @Autowired
    private OrderWorkflowService orderService;  // Same instance across order routes
    
    @Autowired
    @EnvironmentScope
    private UserPreferencesService preferences;  // Per-tab instance
    
    public ShippingView() {
        // Both services maintain appropriate lifecycles
        OrderData order = orderService.getCurrentOrder();
        ShippingPrefs prefs = preferences.getShippingPreferences();
    }
}
```

For even finer control, the `@SharedFrom` annotation lets you customize scope boundaries, restricting bean availability to specific component subtrees. This enforces architectural boundaries with runtime validation, preventing accidental dependencies between unrelated features.

The scope processors handle all the complexity of bean storage, cleanup, and isolation. When environments terminate or routes change, destruction callbacks fire automatically, ensuring proper resource cleanup without memory leaks.

- Use `@EnvironmentScope` for user session data, authentication, or tab-specific state
- Use `@RouteScope` for workflow data, form state, or feature-specific services  
- Use standard Spring scopes for stateless services or application-wide singletons

:::info
Learn more about Spring integration and custom scopes in the [Spring Framework integration](/docs/integrations/spring/overview) documentation.
:::

### Table column sizing and moving support

User experience in data-heavy applications often depends on how flexibly users can interact with their data views. The `Table` component in webforJ `25.03` introduces comprehensive column manipulation capabilities that let users resize, reorder, and configure columns to match their workflow needs.

The new column management APIs provide both immediate user interactions and programmatic control. Users can drag column borders to adjust widths, drag column headers to reorder them, and have those preferences persist across sessions. Meanwhile, developers gain precise control over column behavior with methods for setting width constraints, handling resize events, and implementing custom column state management.

This is particularly valuable in complex applications like data analysis dashboards, where users need to focus on specific columns while keeping others minimal, or financial reporting tools where different users prioritize different data points and need columns arranged to match their analysis patterns.

#### Enhanced column control

The new column manipulation features provide both user-facing interactivity and programmatic control:

```java
@Route("/reports/financial")
public class FinancialReportView extends Composite<Div> {
    
    private Table<FinancialRecord> table;
    
    public FinancialReportView() {
        setupTable();
    }
    
    private void setupTable() {
        table = new Table<>();
        
        // Configure columns with resize and move capabilities
        table.addColumn("account", "Account Name")
             .setWidth("200px")
             .setMinWidth("150px")
             .setMaxWidth("300px")
             .setResizable(true);
             
        table.addColumn("amount", "Amount")
             .setWidth("120px")
             .setMovable(true)
             .setFlex(1); // Auto-expand to fill available space
        
        // Handle column events
        table.addColumnResizeListener(event -> {
            String column = event.getColumn();
            double newWidth = event.getNewWidth();
            saveColumnPreference(column, newWidth);
        });
        
        table.addColumnMoveListener(event -> {
            int fromIndex = event.getFromIndex();
            int toIndex = event.getToIndex();
            updateColumnOrder(fromIndex, toIndex);
        });
        
        // Restore user preferences
        loadColumnPreferences();
    }
    
    private void saveColumnPreference(String column, double width) {
        // Persist column width to user preferences
        userPreferences.setColumnWidth(column, width);
    }
    
    private void loadColumnPreferences() {
        // Apply saved column preferences on startup
        userPreferences.getColumnWidths().forEach((column, width) -> {
            table.getColumn(column).setWidth(width + "px");
        });
    }
}
```

The column manipulation APIs support several key use cases:

- **`setResizable(true)`** enables user column resizing with mouse interaction
- **`setMovable(true)`** allows drag-and-drop column reordering
- **Width constraints** with `setMinWidth()` and `setMaxWidth()` prevent columns from becoming too narrow or wide
- **Flex sizing** with `setFlex()` makes columns automatically expand to fill available space
- **Event listeners** capture resize and move operations for preference persistence

<ComponentDemo 
path='/webforj/table?' 
javaE='https://raw.githubusercontent.com/webforj/webforj-documentation/refs/heads/main/src/main/java/com/webforj/samples/views/table/TableColumnsView.java'
height="400px"
/>

:::info
For comprehensive table configuration options, visit the [Table component](/docs/components/table/overview) documentation.
:::

## Upgrade notes

When upgrading to `25.03`, be aware of the following:

- Spring Boot projects can now leverage the new configuration and scoping features
- Existing lifecycle hooks remain compatible with the new early lifecycle system
- Table components automatically support the new column features without code changes

webforJ `25.03` strengthens the framework's enterprise capabilities with enhanced Spring integration and improved component behavior. We're excited to see what you build with these new features!