---
title: What's new in version 25.10?
description: Get to know the features, fixes, and functionality new in webforJ version 25.10.
slug: whats-new-v25.10
date: 2025-11-11
authors: webforJ
tags: [webforJ, v25.10, release]
image: "https://cdn.webforj.com/webforj-documentation/blogs/webforj-v25.10/cover.png"
hide_table_of_contents: false
---

![cover image](https://cdn.webforj.com/webforj-documentation/blogs/webforj-v25.10/cover.png)

webforJ version `25.10` introduces some heavy hitting new capabilities for building global, secure, and integrated applications. This release brings internationalization support, enterprise-grade security which includes Spring Security integration, Webswing compatibility for legacy Java Swing apps, and adds to our `Login` component.

<!-- truncate -->

As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.10) for a more comprehensive list of changes. Highlighted below are some of the most exciting changes:

## Route Security with Spring Security integration

Securing web applications has always presented a challenge: scatter authentication checks throughout your codebase and risk missing critical access points, or build complex authorization layers that become maintenance nightmares. webforJ `25.10` solves this with a comprehensive **Route Security** system that brings enterprise-grade route protection directly to your webforJ apps.

The new security framework introduces **declarative route-level access control**, where you protect views, require authentication, and enforce role-based permissions using annotations. The security system automatically evaluates these rules before any component renders, allowing for centralized, consistent enforcement across your entire app.

### Spring Security: The recommended implementation

For teams building new applications or those already using Spring Boot, webforJ `25.10` provides integration with Spring Security - the industry-standard authentication and authorization framework. Add the Spring Security starter dependency, configure your security rules, and protect routes with annotations:

```java title="Protecting routes with annotations"
// Public login page - accessible to everyone
@Route("/login")
@AnonymousAccess // Allows everyone to access this page
public class LoginView extends Composite<Login> { }

// Dashboard - requires authentication
@Route("/dashboard")
public class DashboardView extends Composite<Div> { }

// Admin panel - requires specific role
@Route("/admin")
@RolesAllowed("ADMIN") // Restricts access to those with ADMIN role
public class AdminView extends Composite<Div> { }
```

The Spring Security integration handles the heavy lifting automatically. When users navigate to protected routes, the system intercepts navigation, verifies credentials and permissions, and either grants access or redirects appropriately without needing checks in your `View` code.

### Core capabilities

**Annotation-based security**: Use [simple annotations to mark routes](/docs/security/annotations) with `@AnonymousAccess`, `@PermitAll`, `@RolesAllowed`, or `@DenyAll` to define access requirements declaratively. The framework enforces these rules consistently across your application.

**Spring Security integration**: Leverage Spring's authentication framework, password encoders, session management, and user stores while building modern UIs with webforJ. Existing Spring Security configurations work alongside webforJ routing.

**SpEL expressions**: Use [Spring Expression Language](/docs/security/spel-expressions) for complex authorization logic directly in annotations. Combine roles, authorities, and custom conditions:

```java
@Route("/reports/advanced")
@RouteAccess("hasAnyRole('ADMIN', 'MANAGER', 'SUPERVISOR')")
public class AdvancedReportsView extends Composite<Div> { }
```

**Custom evaluators**: Extend the security system with business logic that depends on request context. Verify resource ownership, check dynamic permissions, or integrate with external authorization services. This can be helpful in situations such as users attempting to edit profiles they do not own:

```java
@Route("/users/:userId/edit")
@RequireOwnership("userId")
public class EditProfileView extends Composite<Div> {
  // Users can only edit their own profile
}
```

**Secure-by-default mode**: Enable a configuration option that requires authentication for all routes unless explicitly marked public. This reduces the risk of accidentally exposing protected content and aligns with security best practices.

**Access to authenticated user**: Retrieve user information anywhere in your application through [Spring Security's `SecurityContextHolder`](/docs/security/accessing-user). Display personalized content, implement conditional rendering based on roles, or make authorization decisions in your business logic.

### Flexible architecture for existing systems

While Spring Security is integrated without the need for additional work on the developer's part, the Route Security system is built on an extensible architecture that can work with your existing authentication infrastructure. Teams with established authentication systems - be they custom implementations, alternative Java security frameworks, or enterprise identity providers - can implement custom security providers to bridge webforJ routing with their current authorization logic.

This means you don't need to replace your existing authentication systems to adopt webforJ. The [Security Architecture guide](/docs/security/architecture/overview) provides comprehensive documentation for custom implementations, including a complete working example that demonstrates how to build a plain Java security provider.

### Getting started

To start using webforJ and Spring's security features, simply add `spring-boot-starter-security` to your dependencies, create a `SecurityConfig` that defines your authentication rules and protected routes, build your login view, and annotate routes with security requirements. The [Getting Started guide](/docs/security/getting-started) walks through each step with working examples.

:::info
Explore the complete security documentation at [Security](/docs/security/overview) for detailed implementation guides, advanced patterns, and architectural deep-dives.
:::

## Webswing integration for progressive modernization

Many organizations maintain Java Swing applications built over years, *or even decades* - apps containing critical business logic that can't be easily recreated. These apps generally work well, but face modern challenges: users expect web access, mobile compatibility, and contemporary interfaces. 

A complete rewrite risks adding new languages or techs, losing functionality, introducing bugs in established logic, and requires massive time and budget investments.

To combat this issue, webforJ `25.10` introduces **Webswing integration**, which solves this through a progressive modernization path. Instead of choosing between keeping your legacy app or rewriting from scratch, you can now have both: get your Swing app on the web immediately, then incrementally replace components with modern webforJ equivalents at your own pace.

### Immediate web deployment, zero code changes

Webswing is a web server technology that renders Java desktop applications (Swing, JavaFX, SWT) in browsers without modifying source code. Your existing Swing app runs on the server, and Webswing streams the interface to browsers using HTML5 canvas, handling all user interactions transparently.

After [basic configuration](/docs/integrations/webswing/setup) of the Webswing server and webforJ dependency, the new `WebswingConnector` component embeds Webswing-hosted applications directly within your webforJ app:

```java
@Route
public class SwingAppView extends Composite<Div> {
  private WebswingConnector connector;

  public SwingAppView() {
    // Initialize the connector with your Webswing application URL
    connector = new WebswingConnector("http://localhost:8080/myapp/");

    // Set the display dimensions
    connector.setSize("100%", "600px");

    // Add to the view container
    getBoundComponent().add(connector);
  }
}
```

Your users get immediate web access to functionality they depend on, while you gain time to plan and execute a thoughtful modernization strategy.

### The piecewise upgrade path

The real power of Webswing integration lies in progressive enhancement. Rather than an all-or-nothing rewrite - one that often requires learning new technologies or languages - you can modernize incrementally in Java:

**Phase 1: Embed and extend**
Start by embedding your entire Swing app through the `WebswingConnector` as shown above. Build new web features around it using webforJ—modern components, layouts, routing, etc - the core Swing functionality remains unchanged and functional.

**Phase 2: Replace high-value components**
Identify components where modern web UIs provide clear benefits: forms, dialogs, data entry screens. Replace these with webforJ equivalents while keeping the rest of the Swing app intact. For example, replace a Swing edit dialog with a modern webforJ dialog:

```java
// In your Swing app: send event when user wants to edit
api.sendActionEvent("edit-customer", gson.toJson(customer), null);

// In your webforJ app: handle with modern web UI
connector.onAction(event -> {
  if ("edit-customer".equals(event.getActionName())) {
    event.getActionData().ifPresent(data -> {
      Customer customer = parseCustomer(data);
      CustomerDialog dialog = new CustomerDialog(customer);
      dialog.onSave(() -> {
        // Send updates back to Swing to keep data in sync
        connector.performAction("update-customer", gson.toJson(customer));
      });
    });
  }
});
```

**Phase 3: Gradual component replacement**
Continue replacing Swing components with webforJ equivalents based on business priorities, user feedback, and development capacity. The bidirectional communication between webforJ and Swing keeps both sides synchronized.

**Phase 4: Complete modernization**
Eventually, the Swing app shrinks to a minimal set of irreplaceable functionality, or disappears entirely as you complete the migration. Throughout this journey, your users maintain access to a working application, and the Java logic remains the same.

:::info Modernization Tutorial
For a more in-depth overview of piecewise modernization and the code needed to achieve this, see [this section of the docs](/docs/integrations/webswing/tutorial).
:::

### Risk mitigation and flexibility

This approach provides safety nets that a complete rewrite can't offer:

- **Fallback capability**: The original Swing app remains functional as a standalone desktop app if web deployment encounters issues
- **Gradual user migration**: Roll out changes incrementally and gather feedback before committing to larger rewrites
- **Preserved business logic**: Complex domain logic stays in place, tested and working, while you modernize the presentation layer
- **Resource optimization**: Allocate development resources to high-impact areas first, deferring lower-priority components

### Architecture and communication

The integration operates through three layers: the Webswing server running your desktop app, the `WebswingConnector` component managing the browser connection, and a bidirectional messaging protocol that allows webforJ apps to send commands to Swing and receive events back. This architecture maintains the full functionality of your Swing app while allowing the UI to be upgraded with modern web components.

### Getting started

Setting up Webswing integration involves downloading and configuring the Webswing server to host your Swing app, adding the `webforj-webswing` dependency to your webforJ project, and creating views with the `WebswingConnector` component. The [Webswing integration guide](/docs/integrations/webswing/overview) provides complete setup instructions, and the [modernization tutorial](/docs/integrations/webswing/tutorial) walks through a real-world example of progressively replacing Swing components with webforJ equivalents.

:::info
Explore the complete Webswing integration documentation at [Webswing Integration](/docs/integrations/webswing/overview) for setup guides, communication patterns, and modernization strategies.
:::

## Internationalization and localization support

Building applications for global audiences requires more than just translating text - it requires a system that keeps every component synchronized when a user switches languages. Traditional approaches scatter translation logic throughout the codebase, requiring manual coordination between language selection and UI updates. Miss a single component during a locale change, and users see a jarring mix of languages.

webforJ `25.10` introduces a **comprehensive localization system** that solves this through automatic locale change notifications. Components implementing the `LocaleObserver` interface receive instant notifications when users change languages, enabling coordinated UI updates across your entire application without manual event wiring.

### Automatic locale change propagation

The localization system centers on the `LocaleObserver` interface—a simple contract that components implement to handle language transitions:

```java
public class NavigationMenu extends Composite<FlexLayout> implements LocaleObserver {
  private ResourceBundle bundle;
  private H3 titleElement;
  private Anchor helpLink;

  public NavigationMenu() {
    // Load initial translations
    bundle = ResourceBundle.getBundle("messages", App.getLocale());

    titleElement = new H3(bundle.getString("menu.inbox"));
    helpLink = new Anchor("#", bundle.getString("menu.help"));

    getBoundComponent().add(titleElement, helpLink);
  }

  @Override
  public void onLocaleChange(LocaleEvent event) {
    // Automatically called when locale changes
    bundle = ResourceBundle.getBundle("messages", event.getLocale());
    titleElement.setText(bundle.getString("menu.inbox"));
    helpLink.setText(bundle.getString("menu.help"));
  }
}
```

When your app calls `App.setLocale(Locale.GERMAN)`, every component implementing `LocaleObserver` receives the `onLocaleChange()` callback instantly. No manual event registration, no subscription management, no risk of missing components—the framework handles coordination automatically.

### Integration with standard Java translation tools

The localization system works with Java's `ResourceBundle` API without the need for extra tweaking, enabling traditional property file-based translations:

```
resources/
  messages.properties          # Fallback translations
  messages_en.properties       # English
  messages_es.properties       # Spanish
  messages_de.properties       # German
  messages_fr.properties       # French
```

Each property file contains your translations using standard key-value pairs:

```properties
# messages_en.properties
app.title=Mailbox
menu.inbox=Inbox
menu.sent=Sent Items

# messages_es.properties
app.title=Buzón
menu.inbox=Bandeja de entrada
menu.sent=Elementos enviados
```

This standard approach means you can use existing translation workflows, tooling, and property file editors. But the system doesn't prescribe translation sources—you can load translations from databases, REST APIs, custom providers, or any source that fits your architecture.

### Practical language switching

Implementing a language selector becomes straightforward with automatic propagation:

```java
ChoiceBox languageSelector = new ChoiceBox();
languageSelector.add("en", "English");
languageSelector.add("de", "Deutsch");
languageSelector.add("fr", "Français");

languageSelector.onSelect(e -> {
  String languageTag = (String) e.getSelectedItem().getKey();
  App.setLocale(Locale.forLanguageTag(languageTag));
  // Every LocaleObserver in your app is now notified automatically
});
```

A single line triggers coordinated updates across your entire application—navigation menus, form labels, dialog messages, error text, and any other components implementing `LocaleObserver` all refresh simultaneously with translations for the selected language.

The localization system in `25.10` makes internationalization in webforJ simple, providing the foundation for building apps that serve global audiences. Whether you're adding an additional language to an existing app or building a platform that supports dozens of locales, the automatic notification system keeps consistent, coordinated translations throughout your user interface. The system also provides proper isolation in multi-app deployments, so locale changes in one application don't affect other applications running on the same server.

<!-- TODO -->
:::info TODO-ADD LINK
:::

## Login component enhancements

In addition to the Route Security addition, the `Login` component in webforJ `25.10` has been given new capabilities that allow it to integrate with traditional authentication backends and extended authentication workflows.

### Form action support for direct submission

The `Login` component now supports direct form submission through the `setAction()` method, enabling traditional POST-based authentication flows. This makes working with frameworks like Spring Security straightforward - simply point the login component at your authentication endpoint:

```java
@Route("/login")
@AnonymousAccess
public class LoginView extends Composite<Login> {
  private final Login login = getBoundComponent();

  public LoginView() {
    // Submit directly to Spring Security's authentication endpoint
    login.setAction("/login");

    whenAttached().thenAccept(c -> login.open());
  }
}
```

When users submit the form, the component automatically POSTs credentials to the configured endpoint using standard form parameters (`username` and `password`). Backend frameworks intercept the submission, verify credentials, and handle authentication without requiring JavaScript event listeners or manual form handling. This approach works naturally with server-side authentication systems that expect traditional form submissions.

### Custom fields for extended authentication

Authentication workflows often require more than just username and password—you might need department codes, security questions, two-factor tokens, or tenant identifiers. The enhanced `Login` component now supports custom fields that flow through to both form submissions and event handlers:

```java
login.onSubmit(event -> {
  String username = event.getUsername();
  String password = event.getPassword();

  // Access custom fields through event data
  String departmentCode = (String) event.getData().get("department");
  String token = (String) event.getData().get("token");

  authenticateWithExtendedCredentials(username, password, departmentCode, token);
});
```

This extensibility means the `Login` component adapts to diverse authentication requirements without component modifications or workarounds. Add fields through the underlying web component customization, and they automatically become available in your authentication logic.

### Backward compatibility maintained

These enhancements maintain full backward compatibility with existing `Login` component usage. Applications using event-based authentication (`onSubmit()` handlers) continue working without changes. The new form action capability provides an alternative approach for scenarios where direct backend submission makes sense, particularly when integrating with authentication systems built around traditional form handling.

Together with Route Security, the enhanced `Login` component completes the authentication story in webforJ `25.10`, providing flexible options that work with both modern event-driven patterns and traditional server-side authentication architectures.

## Upgrade notes

When upgrading to `25.10`, be aware of the following:

[Upgrade notes to be added]

`25.10` represents a significant step forward for webforJ, bringing enterprise-grade features that enable building secure, global, and integrated applications. We're excited to see what you build with these new capabilities!
