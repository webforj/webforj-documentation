---
title: What's new in version 25.03?
description: Get to know the features, fixes, and functionality new in webforJ version 25.03.
slug: whats-new-v25.03
date: 2025-09-05
authors: webforJ
tags: [webforJ, v25.03, release]
image: "https://docs.webforj.com/release_blog/_images/25.03.png"
hide_table_of_contents: false
---

![cover image](/release_blog/_images/25.03.png)

webforJ version `25.03` introduces new capabilities for configuration management, Spring integration options, routing improvements, and `Table` component updates.

<!-- truncate -->

As always, see the [GitHub release overview](https://github.com/webforj/webforj/releases/tag/25.03) for a more comprehensive list of changes. Highlighted below are some of the most exciting changes:

## New features and enhancements ðŸŽ‰

### Early lifecycle hooks for configuration management

webforJ `25.03` introduces `onWillCreate` and `onDidCreate` lifecycle hooks that give control over app initialization. These new hooks fire at critical moments during startup â€“ `onWillCreate` executes before your app instance is created, while `onDidCreate` runs immediately after creation but before serving requests.

These additions solve a common challenge in enterprise applications: performing operations like validating environment variables, configuring logging systems, or establishing database connections at exactly the right moment during startup. With these hooks, you can now modify configuration before it locks, validate prerequisites, and set up resources your app depends on â€“ all with clean, declarative code using the `@AppLifecycleListener` annotation.

:::info
For implementation details, see the [Lifecycle Listeners](/docs/advanced/lifecycle-listeners) documentation.
:::

### Spring properties file configuration support

Configuration with Spring Boot has seen improvements in `25.03`. Configure your webforJ applications directly in `application.properties` or `application.yml` files using the `webforj.*` prefix â€“ from servlet mappings and debug settings to file upload limits and custom servlet registration.

This integration utilizes Spring's profile system, which allows you to maintain separate configurations for development, staging, and production environments. It's possible to switch between profiles with a single command-line argument or environment variable, and your webforJ app automatically picks up the right configuration. 

The system respects Spring Boot's configuration hierarchy, so properties from environment variables, command-line arguments, and external configuration sources all work as expected.

:::tip Migration path
Moving from `webforj.conf` to Spring properties? Both approaches work side-by-side during migration. Spring properties take precedence when both are present, allowing for gradual transition.
:::

:::info
For configuration examples and details, see the [Spring Integration](/docs/integrations/spring/setup) documentation.
:::

### Router Activate lifecycle event for cached components

Routing has been the `ActivateEvent` and `ActivateObserver` interfaces added to handle component reactivation. When users navigate back to a cached component, the `onActivate` method fires, allowing you to refresh data while preserving component state â€“ developers will no longer be forced to choose between recreating entire components or manually checking for changes.

This feature shines in parameter-driven routes. Navigate from `/customer/123` to `/customer/456`, and the component stays cached while `onActivate` provides an opportunity to load new customer data. User inputs, form state, and expensive initializations all persist, while only the relevant data refreshes.

Perfect for complex forms, multi-step workflows, and any scenario where you need to balance performance with data freshness. The clear separation between initial creation and reactivation makes your routing logic more maintainable and your apps more responsive.

### Spring custom scopes for webforJ environments and routes

Version `25.03` introduces three powerful Spring scope annotations designed specifically for component-based architectures: `@EnvironmentScope`, `@RouteScope`, and `@WebforjSessionScope`. These new scopes align bean lifecycles with webforJ's runtime model, ensuring beans exist exactly as long as they're needed.

`@WebforjSessionScope` provides true session-level bean persistence across all browser tabs and windows for a single user. Perfect for authentication state, user preferences, and shopping carts â€“ when a user logs in through one tab, all tabs immediately share the authenticated state. Unlike standard Spring session scope, this implementation is tailored for webforJ's event-driven architecture, working outside traditional HTTP request threads.

`@EnvironmentScope` ties beans to individual browser windows or tabs â€“ each tab gets its own isolated instance, ideal for tab-specific state that shouldn't be shared across windows. Meanwhile, `@RouteScope` binds beans to route hierarchies, where parent and child routes share instances but navigating to different route trees creates fresh beans.

For even finer control, the `@SharedFrom` annotation lets you customize scope boundaries, restricting bean availability to specific component subtrees and enforcing architectural boundaries with runtime validation.

:::info
Learn more about Spring integration and custom scopes in the [Spring Framework integration](/docs/integrations/spring/overview) documentation.
:::

### Table column sizing and moving support

The `Table` has been enhanced in this release to introduce comprehensive column manipulation capabilities. Users can now drag column borders to resize, drag headers to reorder, and have those preferences persist across sessions. 

The new column management APIs offer both interactive and programmatic control. Set width constraints with `setMinWidth()` and `setMaxWidth()`, enable resizing with `setResizable(true)`, allow reordering with `setMovable(true)`, and implement flex sizing with `setFlex()` for responsive layouts. Event listeners for resize and move operations enable preference persistence and custom state management.

These features are particularly valuable in data-heavy applications like financial dashboards and reporting tools, where different users need to arrange columns to match their workflow patterns.

<ComponentDemo 
path='/webforj/datatable?' 
javaE='https://raw.githubusercontent.com/webforj/webforj-documentation/refs/heads/main/src/main/java/com/webforj/samples/views/table/DataTableView.java'
urls={['https://raw.githubusercontent.com/webforj/webforj-documentation/refs/heads/main/src/main/java/com/webforj/samples/views/table/MusicRecord.java', 
'https://raw.githubusercontent.com/webforj/webforj-documentation/refs/heads/main/src/main/java/com/webforj/samples/views/table/Service.java']}
height='600px'
/>

:::info
For detailed implementation, visit the [Table component](/docs/components/table/overview) documentation.
:::

### Object and String Tables for shared data management

In order to globally access shared data across your application, `25.03` introduces `ObjectTable` and `StringTable`. This eliminates any passing of references through component hierarchies or managing singleton patterns for shared state.

`ObjectTable` stores any Java object with simple key-value access, perfect for user sessions, cached data, or cross-component communication. Meanwhile, `StringTable` handles persistent string values, such as for configuration data, environment variables, and application-wide settings that can be pre-configured through your `webforj.conf` file.

Both tables provide static methods like `put()`, `get()`, `contains()`, and `clear()`, accessible from anywhere in your application without instance management. The environment-scoped lifecycle ensures data persists exactly as long as needed â€“ cleared automatically when the app refreshes or terminates.

Additionally, `25.03` introduces `SessionObjectTable` for HTTP session-scoped storage, enabling proper management of user-specific state in servlet environments. This addition completes the storage hierarchy, giving you the right tool for every scoping need.

:::info
Learn more about data storage options in the [Object and String Tables](/docs/advanced/object-string-tables) documentation.
:::

### Automatic browser launch for Spring Boot development

Finally, a little quality of life enhancement for developers - automatic browser has launched in webforJ `25.03`. When running Spring Boot applications in development mode, webforJ can now automatically open your default browser to the application URL, removing the need to manually type localhost addresses.

Configure this feature through simple application properties: enable it with `webforj.devtools.browser.open=true` and choose your preferred host resolution with `webforj.devtools.browser.host`. Whether you prefer `localhost`, your machine's hostname, or a specific IP address for remote access testing, the browser launcher can be configured for your development setup.

## Upgrade notes

When upgrading to `25.03`, be aware of the following:

- Spring Boot projects can now use the new configuration and scoping features
- Existing lifecycle hooks remain compatible with the new early lifecycle system
- Table components automatically support the new column features without code changes

`25.03` strengthens the webforJ's enterprise capabilities with improved Spring integration and component behavior. We're excited to see what you build with these new features!